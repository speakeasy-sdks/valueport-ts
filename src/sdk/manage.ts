/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { SDKConfiguration } from "./sdk";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Operations for managing tenant information.
 */
export class Manage {
    private sdkConfiguration: SDKConfiguration;

    constructor(sdkConfig: SDKConfiguration) {
        this.sdkConfiguration = sdkConfig;
    }

    /**
     * API key - Create
     *
     * @remarks
     * Create a single API key entity.
     */
    async apiKeyCreate(
        req: shared.ApiKeyCreateBody,
        config?: AxiosRequestConfig
    ): Promise<operations.ApiKeyCreateResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new shared.ApiKeyCreateBody(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = baseURL.replace(/\/$/, "") + "/api/v1/manage/api-keys";

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(req, "request", "json");
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...reqBodyHeaders, ...config?.headers };
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        headers["Accept"] = "application/json;q=1, application/json;q=0";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url,
            method: "post",
            headers: headers,
            data: reqBody,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.ApiKeyCreateResponse = new operations.ApiKeyCreateResponse({
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 201:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.apiKeyResponse = utils.objectToClass(httpRes?.data, shared.ApiKeyResponse);
                }
                break;
            case httpRes?.status == 400:
                break;
            case httpRes?.status == 422:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.errorDetailResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.ErrorDetailResponse
                    );
                }
                break;
        }

        return res;
    }

    /**
     * API key - Delete
     *
     * @remarks
     * Delete a single API key entity by ID (soft deletion).
     */
    async apiKeyDelete(
        req: operations.ApiKeyDeleteRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.ApiKeyDeleteResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.ApiKeyDeleteRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = utils.generateURL(baseURL, "/api/v1/manage/api-keys/{id}", req);

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...config?.headers };
        headers["Accept"] = "*/*";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url,
            method: "delete",
            headers: headers,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.ApiKeyDeleteResponse = new operations.ApiKeyDeleteResponse({
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 204:
                break;
        }

        return res;
    }

    /**
     * API key - Fetch
     *
     * @remarks
     * Retrieve a single API key entity by ID.
     */
    async apiKeyFetch(
        req: operations.ApiKeyFetchRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.ApiKeyFetchResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.ApiKeyFetchRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = utils.generateURL(baseURL, "/api/v1/manage/api-keys/{id}", req);

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...config?.headers };
        headers["Accept"] = "application/json";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url,
            method: "get",
            headers: headers,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.ApiKeyFetchResponse = new operations.ApiKeyFetchResponse({
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.apiKeyResponse = utils.objectToClass(httpRes?.data, shared.ApiKeyResponse);
                }
                break;
        }

        return res;
    }

    /**
     * API key - JSON Patch
     *
     * @remarks
     * Update a single API key entity.
     * PATCH with `Content-Type: application/json-patch+json` supports a JSON Patch ([jsonpatch.com](http://jsonpatch.com)) document in `api_key` that has paths relative to schema `ApiKey`.
     */
    async apiKeyJsonPatch(
        req: operations.ApiKeyJsonPatchRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.ApiKeyJsonPatchResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.ApiKeyJsonPatchRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = utils.generateURL(
            baseURL,
            "/api/v1/manage/api-keys/{id}/jsonpatch",
            req
        );

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
                req,
                "apiKeyJsonPatchBody",
                "json"
            );
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...reqBodyHeaders, ...config?.headers };
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        headers["Accept"] = "application/json;q=1, application/json;q=0";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url,
            method: "patch",
            headers: headers,
            data: reqBody,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.ApiKeyJsonPatchResponse = new operations.ApiKeyJsonPatchResponse({
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.apiKeyResponse = utils.objectToClass(httpRes?.data, shared.ApiKeyResponse);
                }
                break;
            case httpRes?.status == 400:
                break;
            case httpRes?.status == 422:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.errorDetailResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.ErrorDetailResponse
                    );
                }
                break;
        }

        return res;
    }

    /**
     * API key - List
     *
     * @remarks
     * Retrieve a list of API key entities by continuation token and page size.
     */
    async apiKeyList(
        req: operations.ApiKeyListRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.ApiKeyListResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.ApiKeyListRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = baseURL.replace(/\/$/, "") + "/api/v1/manage/api-keys";

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...config?.headers };
        const queryParams: string = utils.serializeQueryParams(req);
        headers["Accept"] = "application/json";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url + queryParams,
            method: "get",
            headers: headers,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.ApiKeyListResponse = new operations.ApiKeyListResponse({
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.apiKeysList = utils.objectToClass(httpRes?.data, shared.ApiKeysList);
                }
                break;
        }

        return res;
    }

    /**
     * API key - Paged
     *
     * @remarks
     * Retrieve a list of API key entities by page number and page size.
     */
    async apiKeyListPaged(
        req: operations.ApiKeyListPagedRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.ApiKeyListPagedResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.ApiKeyListPagedRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = baseURL.replace(/\/$/, "") + "/api/v1/manage/api-keys/paged";

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...config?.headers };
        const queryParams: string = utils.serializeQueryParams(req);
        headers["Accept"] = "application/json";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url + queryParams,
            method: "get",
            headers: headers,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.ApiKeyListPagedResponse = new operations.ApiKeyListPagedResponse({
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.apiKeysPaged = utils.objectToClass(httpRes?.data, shared.ApiKeysPaged);
                }
                break;
        }

        return res;
    }

    /**
     * API key - Update
     *
     * @remarks
     * Update a single API key entity.
     * PUT and PATCH update semantics as defined by REST.
     *  - **PUT**: Update properties and assign null where not defined in the request body.
     *  - **PATCH**: Update non-null properties from the request body and leave the remaining intact.
     *
     * See also: [API key - JSON Patch](#operation/api_key-json-patch)
     */
    async apiKeyUpdatePatch(
        req: operations.ApiKeyUpdatePatchRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.ApiKeyUpdatePatchResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.ApiKeyUpdatePatchRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = utils.generateURL(baseURL, "/api/v1/manage/api-keys/{id}", req);

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(req, "apiKeyUpdateBody", "json");
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...reqBodyHeaders, ...config?.headers };
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        headers["Accept"] = "application/json;q=1, application/json;q=0";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url,
            method: "patch",
            headers: headers,
            data: reqBody,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.ApiKeyUpdatePatchResponse = new operations.ApiKeyUpdatePatchResponse({
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.apiKeyResponse = utils.objectToClass(httpRes?.data, shared.ApiKeyResponse);
                }
                break;
            case httpRes?.status == 400:
                break;
            case httpRes?.status == 422:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.errorDetailResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.ErrorDetailResponse
                    );
                }
                break;
        }

        return res;
    }

    /**
     * API key - Update
     *
     * @remarks
     * Update a single API key entity.
     * PUT and PATCH update semantics as defined by REST.
     *  - **PUT**: Update properties and assign null where not defined in the request body.
     *  - **PATCH**: Update non-null properties from the request body and leave the remaining intact.
     *
     * See also: [API key - JSON Patch](#operation/api_key-json-patch)
     */
    async apiKeyUpdatePut(
        req: operations.ApiKeyUpdatePutRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.ApiKeyUpdatePutResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.ApiKeyUpdatePutRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = utils.generateURL(baseURL, "/api/v1/manage/api-keys/{id}", req);

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(req, "apiKeyUpdateBody", "json");
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...reqBodyHeaders, ...config?.headers };
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        headers["Accept"] = "application/json;q=1, application/json;q=0";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url,
            method: "put",
            headers: headers,
            data: reqBody,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.ApiKeyUpdatePutResponse = new operations.ApiKeyUpdatePutResponse({
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.apiKeyResponse = utils.objectToClass(httpRes?.data, shared.ApiKeyResponse);
                }
                break;
            case httpRes?.status == 400:
                break;
            case httpRes?.status == 422:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.errorDetailResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.ErrorDetailResponse
                    );
                }
                break;
        }

        return res;
    }

    /**
     * Contract - Create
     *
     * @remarks
     * Create a single contract entity.
     */
    async contractCreate(
        req: shared.ContractCreateBody,
        config?: AxiosRequestConfig
    ): Promise<operations.ContractCreateResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new shared.ContractCreateBody(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = baseURL.replace(/\/$/, "") + "/api/v1/manage/contracts";

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(req, "request", "json");
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...reqBodyHeaders, ...config?.headers };
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        headers["Accept"] = "application/json;q=1, application/json;q=0";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url,
            method: "post",
            headers: headers,
            data: reqBody,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.ContractCreateResponse = new operations.ContractCreateResponse({
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 201:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.contractResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.ContractResponse
                    );
                }
                break;
            case httpRes?.status == 400:
                break;
            case httpRes?.status == 422:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.errorDetailResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.ErrorDetailResponse
                    );
                }
                break;
        }

        return res;
    }

    /**
     * Contract - Delete
     *
     * @remarks
     * Delete a single contract entity by ID (soft deletion).
     */
    async contractDelete(
        req: operations.ContractDeleteRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.ContractDeleteResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.ContractDeleteRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = utils.generateURL(baseURL, "/api/v1/manage/contracts/{id}", req);

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...config?.headers };
        headers["Accept"] = "*/*";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url,
            method: "delete",
            headers: headers,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.ContractDeleteResponse = new operations.ContractDeleteResponse({
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 204:
                break;
        }

        return res;
    }

    /**
     * Contract - Fetch
     *
     * @remarks
     * Retrieve a single contract entity by ID.
     */
    async contractFetch(
        req: operations.ContractFetchRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.ContractFetchResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.ContractFetchRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = utils.generateURL(baseURL, "/api/v1/manage/contracts/{id}", req);

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...config?.headers };
        headers["Accept"] = "application/json";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url,
            method: "get",
            headers: headers,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.ContractFetchResponse = new operations.ContractFetchResponse({
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.contractResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.ContractResponse
                    );
                }
                break;
        }

        return res;
    }

    /**
     * Contract - JSON Patch
     *
     * @remarks
     * Update a single contract entity.
     * PATCH with `Content-Type: application/json-patch+json` supports a JSON Patch ([jsonpatch.com](http://jsonpatch.com)) document in `contract` that has paths relative to schema `Contract`.
     */
    async contractJsonPatch(
        req: operations.ContractJsonPatchRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.ContractJsonPatchResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.ContractJsonPatchRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = utils.generateURL(
            baseURL,
            "/api/v1/manage/contracts/{id}/jsonpatch",
            req
        );

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
                req,
                "contractJsonPatchBody",
                "json"
            );
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...reqBodyHeaders, ...config?.headers };
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        headers["Accept"] = "application/json;q=1, application/json;q=0";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url,
            method: "patch",
            headers: headers,
            data: reqBody,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.ContractJsonPatchResponse = new operations.ContractJsonPatchResponse({
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.contractResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.ContractResponse
                    );
                }
                break;
            case httpRes?.status == 400:
                break;
            case httpRes?.status == 422:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.errorDetailResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.ErrorDetailResponse
                    );
                }
                break;
        }

        return res;
    }

    /**
     * Contract - List
     *
     * @remarks
     * Retrieve a list of contract entities by continuation token and page size.
     */
    async contractList(
        req: operations.ContractListRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.ContractListResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.ContractListRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = baseURL.replace(/\/$/, "") + "/api/v1/manage/contracts";

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...config?.headers };
        const queryParams: string = utils.serializeQueryParams(req);
        headers["Accept"] = "application/json";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url + queryParams,
            method: "get",
            headers: headers,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.ContractListResponse = new operations.ContractListResponse({
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.contractsList = utils.objectToClass(httpRes?.data, shared.ContractsList);
                }
                break;
        }

        return res;
    }

    /**
     * Contract - Paged
     *
     * @remarks
     * Retrieve a list of contract entities by page number and page size.
     */
    async contractListPaged(
        req: operations.ContractListPagedRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.ContractListPagedResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.ContractListPagedRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = baseURL.replace(/\/$/, "") + "/api/v1/manage/contracts/paged";

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...config?.headers };
        const queryParams: string = utils.serializeQueryParams(req);
        headers["Accept"] = "application/json";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url + queryParams,
            method: "get",
            headers: headers,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.ContractListPagedResponse = new operations.ContractListPagedResponse({
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.contractsPaged = utils.objectToClass(httpRes?.data, shared.ContractsPaged);
                }
                break;
        }

        return res;
    }

    /**
     * Contract - Update
     *
     * @remarks
     * Update a single contract entity.
     * PUT and PATCH update semantics as defined by REST.
     *  - **PUT**: Update properties and assign null where not defined in the request body.
     *  - **PATCH**: Update non-null properties from the request body and leave the remaining intact.
     *
     * See also: [Contract - JSON Patch](#operation/contract-json-patch)
     */
    async contractUpdatePatch(
        req: operations.ContractUpdatePatchRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.ContractUpdatePatchResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.ContractUpdatePatchRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = utils.generateURL(baseURL, "/api/v1/manage/contracts/{id}", req);

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
                req,
                "contractUpdateBody",
                "json"
            );
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...reqBodyHeaders, ...config?.headers };
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        headers["Accept"] = "application/json;q=1, application/json;q=0";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url,
            method: "patch",
            headers: headers,
            data: reqBody,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.ContractUpdatePatchResponse =
            new operations.ContractUpdatePatchResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.contractResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.ContractResponse
                    );
                }
                break;
            case httpRes?.status == 400:
                break;
            case httpRes?.status == 422:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.errorDetailResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.ErrorDetailResponse
                    );
                }
                break;
        }

        return res;
    }

    /**
     * Contract - Update
     *
     * @remarks
     * Update a single contract entity.
     * PUT and PATCH update semantics as defined by REST.
     *  - **PUT**: Update properties and assign null where not defined in the request body.
     *  - **PATCH**: Update non-null properties from the request body and leave the remaining intact.
     *
     * See also: [Contract - JSON Patch](#operation/contract-json-patch)
     */
    async contractUpdatePut(
        req: operations.ContractUpdatePutRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.ContractUpdatePutResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.ContractUpdatePutRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = utils.generateURL(baseURL, "/api/v1/manage/contracts/{id}", req);

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
                req,
                "contractUpdateBody",
                "json"
            );
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...reqBodyHeaders, ...config?.headers };
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        headers["Accept"] = "application/json;q=1, application/json;q=0";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url,
            method: "put",
            headers: headers,
            data: reqBody,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.ContractUpdatePutResponse = new operations.ContractUpdatePutResponse({
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.contractResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.ContractResponse
                    );
                }
                break;
            case httpRes?.status == 400:
                break;
            case httpRes?.status == 422:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.errorDetailResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.ErrorDetailResponse
                    );
                }
                break;
        }

        return res;
    }

    /**
     * Customer - Create
     *
     * @remarks
     * Create a single customer entity.
     */
    async customerCreate(
        req: shared.CustomerCreateBody,
        config?: AxiosRequestConfig
    ): Promise<operations.CustomerCreateResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new shared.CustomerCreateBody(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = baseURL.replace(/\/$/, "") + "/api/v1/manage/customers";

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(req, "request", "json");
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...reqBodyHeaders, ...config?.headers };
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        headers["Accept"] = "application/json;q=1, application/json;q=0";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url,
            method: "post",
            headers: headers,
            data: reqBody,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.CustomerCreateResponse = new operations.CustomerCreateResponse({
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 201:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.customerResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.CustomerResponse
                    );
                }
                break;
            case httpRes?.status == 400:
                break;
            case httpRes?.status == 422:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.errorDetailResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.ErrorDetailResponse
                    );
                }
                break;
        }

        return res;
    }

    /**
     * Customer - Delete
     *
     * @remarks
     * Delete a single customer entity by ID (soft deletion).
     */
    async customerDelete(
        req: operations.CustomerDeleteRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.CustomerDeleteResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.CustomerDeleteRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = utils.generateURL(baseURL, "/api/v1/manage/customers/{id}", req);

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...config?.headers };
        headers["Accept"] = "*/*";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url,
            method: "delete",
            headers: headers,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.CustomerDeleteResponse = new operations.CustomerDeleteResponse({
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 204:
                break;
        }

        return res;
    }

    /**
     * Customer - Fetch
     *
     * @remarks
     * Retrieve a single customer entity by ID.
     */
    async customerFetch(
        req: operations.CustomerFetchRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.CustomerFetchResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.CustomerFetchRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = utils.generateURL(baseURL, "/api/v1/manage/customers/{id}", req);

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...config?.headers };
        headers["Accept"] = "application/json";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url,
            method: "get",
            headers: headers,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.CustomerFetchResponse = new operations.CustomerFetchResponse({
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.customerResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.CustomerResponse
                    );
                }
                break;
        }

        return res;
    }

    /**
     * Customer - JSON Patch
     *
     * @remarks
     * Update a single customer entity.
     * PATCH with `Content-Type: application/json-patch+json` supports a JSON Patch ([jsonpatch.com](http://jsonpatch.com)) document in `customer` that has paths relative to schema `Customer`.
     */
    async customerJsonPatch(
        req: operations.CustomerJsonPatchRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.CustomerJsonPatchResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.CustomerJsonPatchRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = utils.generateURL(
            baseURL,
            "/api/v1/manage/customers/{id}/jsonpatch",
            req
        );

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
                req,
                "customerJsonPatchBody",
                "json"
            );
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...reqBodyHeaders, ...config?.headers };
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        headers["Accept"] = "application/json;q=1, application/json;q=0";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url,
            method: "patch",
            headers: headers,
            data: reqBody,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.CustomerJsonPatchResponse = new operations.CustomerJsonPatchResponse({
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.customerResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.CustomerResponse
                    );
                }
                break;
            case httpRes?.status == 400:
                break;
            case httpRes?.status == 422:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.errorDetailResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.ErrorDetailResponse
                    );
                }
                break;
        }

        return res;
    }

    /**
     * Customer - List
     *
     * @remarks
     * Retrieve a list of customer entities by continuation token and page size.
     */
    async customerList(
        req: operations.CustomerListRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.CustomerListResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.CustomerListRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = baseURL.replace(/\/$/, "") + "/api/v1/manage/customers";

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...config?.headers };
        const queryParams: string = utils.serializeQueryParams(req);
        headers["Accept"] = "application/json";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url + queryParams,
            method: "get",
            headers: headers,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.CustomerListResponse = new operations.CustomerListResponse({
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.customersList = utils.objectToClass(httpRes?.data, shared.CustomersList);
                }
                break;
        }

        return res;
    }

    /**
     * Customer - Paged
     *
     * @remarks
     * Retrieve a list of customer entities by page number and page size.
     */
    async customerListPaged(
        req: operations.CustomerListPagedRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.CustomerListPagedResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.CustomerListPagedRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = baseURL.replace(/\/$/, "") + "/api/v1/manage/customers/paged";

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...config?.headers };
        const queryParams: string = utils.serializeQueryParams(req);
        headers["Accept"] = "application/json";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url + queryParams,
            method: "get",
            headers: headers,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.CustomerListPagedResponse = new operations.CustomerListPagedResponse({
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.customersPaged = utils.objectToClass(httpRes?.data, shared.CustomersPaged);
                }
                break;
        }

        return res;
    }

    /**
     * Customer - Update
     *
     * @remarks
     * Update a single customer entity.
     * PUT and PATCH update semantics as defined by REST.
     *  - **PUT**: Update properties and assign null where not defined in the request body.
     *  - **PATCH**: Update non-null properties from the request body and leave the remaining intact.
     *
     * See also: [Customer - JSON Patch](#operation/customer-json-patch)
     */
    async customerUpdatePatch(
        req: operations.CustomerUpdatePatchRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.CustomerUpdatePatchResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.CustomerUpdatePatchRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = utils.generateURL(baseURL, "/api/v1/manage/customers/{id}", req);

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
                req,
                "customerUpdateBody",
                "json"
            );
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...reqBodyHeaders, ...config?.headers };
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        headers["Accept"] = "application/json;q=1, application/json;q=0";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url,
            method: "patch",
            headers: headers,
            data: reqBody,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.CustomerUpdatePatchResponse =
            new operations.CustomerUpdatePatchResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.customerResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.CustomerResponse
                    );
                }
                break;
            case httpRes?.status == 400:
                break;
            case httpRes?.status == 422:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.errorDetailResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.ErrorDetailResponse
                    );
                }
                break;
        }

        return res;
    }

    /**
     * Customer - Update
     *
     * @remarks
     * Update a single customer entity.
     * PUT and PATCH update semantics as defined by REST.
     *  - **PUT**: Update properties and assign null where not defined in the request body.
     *  - **PATCH**: Update non-null properties from the request body and leave the remaining intact.
     *
     * See also: [Customer - JSON Patch](#operation/customer-json-patch)
     */
    async customerUpdatePut(
        req: operations.CustomerUpdatePutRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.CustomerUpdatePutResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.CustomerUpdatePutRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = utils.generateURL(baseURL, "/api/v1/manage/customers/{id}", req);

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
                req,
                "customerUpdateBody",
                "json"
            );
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...reqBodyHeaders, ...config?.headers };
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        headers["Accept"] = "application/json;q=1, application/json;q=0";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url,
            method: "put",
            headers: headers,
            data: reqBody,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.CustomerUpdatePutResponse = new operations.CustomerUpdatePutResponse({
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.customerResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.CustomerResponse
                    );
                }
                break;
            case httpRes?.status == 400:
                break;
            case httpRes?.status == 422:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.errorDetailResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.ErrorDetailResponse
                    );
                }
                break;
        }

        return res;
    }

    /**
     * Equipment - Create
     *
     * @remarks
     * Create a single equipment entity.
     */
    async equipmentCreate(
        req: shared.EquipmentCreateBody,
        config?: AxiosRequestConfig
    ): Promise<operations.EquipmentCreateResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new shared.EquipmentCreateBody(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = baseURL.replace(/\/$/, "") + "/api/v1/manage/equipment";

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(req, "request", "json");
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...reqBodyHeaders, ...config?.headers };
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        headers["Accept"] = "application/json;q=1, application/json;q=0";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url,
            method: "post",
            headers: headers,
            data: reqBody,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.EquipmentCreateResponse = new operations.EquipmentCreateResponse({
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 201:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.equipmentResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.EquipmentResponse
                    );
                }
                break;
            case httpRes?.status == 400:
                break;
            case httpRes?.status == 422:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.errorDetailResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.ErrorDetailResponse
                    );
                }
                break;
        }

        return res;
    }

    /**
     * Equipment - Delete
     *
     * @remarks
     * Delete a single equipment entity by ID (soft deletion).
     */
    async equipmentDelete(
        req: operations.EquipmentDeleteRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.EquipmentDeleteResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.EquipmentDeleteRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = utils.generateURL(baseURL, "/api/v1/manage/equipment/{id}", req);

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...config?.headers };
        headers["Accept"] = "*/*";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url,
            method: "delete",
            headers: headers,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.EquipmentDeleteResponse = new operations.EquipmentDeleteResponse({
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 204:
                break;
        }

        return res;
    }

    /**
     * Equipment - Fetch
     *
     * @remarks
     * Retrieve a single equipment entity by ID.
     */
    async equipmentFetch(
        req: operations.EquipmentFetchRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.EquipmentFetchResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.EquipmentFetchRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = utils.generateURL(baseURL, "/api/v1/manage/equipment/{id}", req);

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...config?.headers };
        headers["Accept"] = "application/json";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url,
            method: "get",
            headers: headers,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.EquipmentFetchResponse = new operations.EquipmentFetchResponse({
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.equipmentResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.EquipmentResponse
                    );
                }
                break;
        }

        return res;
    }

    /**
     * Equipment - JSON Patch
     *
     * @remarks
     * Update a single equipment entity.
     * PATCH with `Content-Type: application/json-patch+json` supports a JSON Patch ([jsonpatch.com](http://jsonpatch.com)) document in `equipment` that has paths relative to schema `Equipment`.
     */
    async equipmentJsonPatch(
        req: operations.EquipmentJsonPatchRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.EquipmentJsonPatchResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.EquipmentJsonPatchRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = utils.generateURL(
            baseURL,
            "/api/v1/manage/equipment/{id}/jsonpatch",
            req
        );

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
                req,
                "equipmentJsonPatchBody",
                "json"
            );
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...reqBodyHeaders, ...config?.headers };
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        headers["Accept"] = "application/json;q=1, application/json;q=0";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url,
            method: "patch",
            headers: headers,
            data: reqBody,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.EquipmentJsonPatchResponse =
            new operations.EquipmentJsonPatchResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.equipmentResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.EquipmentResponse
                    );
                }
                break;
            case httpRes?.status == 400:
                break;
            case httpRes?.status == 422:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.errorDetailResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.ErrorDetailResponse
                    );
                }
                break;
        }

        return res;
    }

    /**
     * Equipment - List
     *
     * @remarks
     * Retrieve a list of equipment entities by continuation token and page size.
     */
    async equipmentList(
        req: operations.EquipmentListRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.EquipmentListResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.EquipmentListRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = baseURL.replace(/\/$/, "") + "/api/v1/manage/equipment";

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...config?.headers };
        const queryParams: string = utils.serializeQueryParams(req);
        headers["Accept"] = "application/json";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url + queryParams,
            method: "get",
            headers: headers,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.EquipmentListResponse = new operations.EquipmentListResponse({
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.equipmentList = utils.objectToClass(httpRes?.data, shared.EquipmentList);
                }
                break;
        }

        return res;
    }

    /**
     * Equipment - Paged
     *
     * @remarks
     * Retrieve a list of equipment entities by page number and page size.
     */
    async equipmentListPaged(
        req: operations.EquipmentListPagedRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.EquipmentListPagedResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.EquipmentListPagedRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = baseURL.replace(/\/$/, "") + "/api/v1/manage/equipment/paged";

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...config?.headers };
        const queryParams: string = utils.serializeQueryParams(req);
        headers["Accept"] = "application/json";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url + queryParams,
            method: "get",
            headers: headers,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.EquipmentListPagedResponse =
            new operations.EquipmentListPagedResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.equipmentPaged = utils.objectToClass(httpRes?.data, shared.EquipmentPaged);
                }
                break;
        }

        return res;
    }

    /**
     * Equipment type - Create
     *
     * @remarks
     * Create a single equipment type entity.
     */
    async equipmentTypeCreate(
        req: shared.EquipmentTypeCreateBody,
        config?: AxiosRequestConfig
    ): Promise<operations.EquipmentTypeCreateResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new shared.EquipmentTypeCreateBody(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = baseURL.replace(/\/$/, "") + "/api/v1/manage/equipment-types";

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(req, "request", "json");
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...reqBodyHeaders, ...config?.headers };
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        headers["Accept"] = "application/json;q=1, application/json;q=0";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url,
            method: "post",
            headers: headers,
            data: reqBody,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.EquipmentTypeCreateResponse =
            new operations.EquipmentTypeCreateResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
        switch (true) {
            case httpRes?.status == 201:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.equipmentTypeResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.EquipmentTypeResponse
                    );
                }
                break;
            case httpRes?.status == 400:
                break;
            case httpRes?.status == 422:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.errorDetailResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.ErrorDetailResponse
                    );
                }
                break;
        }

        return res;
    }

    /**
     * Equipment type - Delete
     *
     * @remarks
     * Delete a single equipment type entity by ID (soft deletion).
     */
    async equipmentTypeDelete(
        req: operations.EquipmentTypeDeleteRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.EquipmentTypeDeleteResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.EquipmentTypeDeleteRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = utils.generateURL(baseURL, "/api/v1/manage/equipment-types/{id}", req);

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...config?.headers };
        headers["Accept"] = "*/*";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url,
            method: "delete",
            headers: headers,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.EquipmentTypeDeleteResponse =
            new operations.EquipmentTypeDeleteResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
        switch (true) {
            case httpRes?.status == 204:
                break;
        }

        return res;
    }

    /**
     * Equipment type - Fetch
     *
     * @remarks
     * Retrieve a single equipment type entity by ID.
     */
    async equipmentTypeFetch(
        req: operations.EquipmentTypeFetchRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.EquipmentTypeFetchResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.EquipmentTypeFetchRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = utils.generateURL(baseURL, "/api/v1/manage/equipment-types/{id}", req);

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...config?.headers };
        headers["Accept"] = "application/json";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url,
            method: "get",
            headers: headers,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.EquipmentTypeFetchResponse =
            new operations.EquipmentTypeFetchResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.equipmentTypeResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.EquipmentTypeResponse
                    );
                }
                break;
        }

        return res;
    }

    /**
     * Equipment type - JSON Patch
     *
     * @remarks
     * Update a single equipment type entity.
     * PATCH with `Content-Type: application/json-patch+json` supports a JSON Patch ([jsonpatch.com](http://jsonpatch.com)) document in `equipment_type` that has paths relative to schema `EquipmentType`.
     */
    async equipmentTypeJsonPatch(
        req: operations.EquipmentTypeJsonPatchRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.EquipmentTypeJsonPatchResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.EquipmentTypeJsonPatchRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = utils.generateURL(
            baseURL,
            "/api/v1/manage/equipment-types/{id}/jsonpatch",
            req
        );

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
                req,
                "equipmentTypeJsonPatchBody",
                "json"
            );
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...reqBodyHeaders, ...config?.headers };
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        headers["Accept"] = "application/json;q=1, application/json;q=0";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url,
            method: "patch",
            headers: headers,
            data: reqBody,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.EquipmentTypeJsonPatchResponse =
            new operations.EquipmentTypeJsonPatchResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.equipmentTypeResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.EquipmentTypeResponse
                    );
                }
                break;
            case httpRes?.status == 400:
                break;
            case httpRes?.status == 422:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.errorDetailResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.ErrorDetailResponse
                    );
                }
                break;
        }

        return res;
    }

    /**
     * Equipment type - List
     *
     * @remarks
     * Retrieve a list of equipment type entities by continuation token and page size.
     */
    async equipmentTypeList(
        req: operations.EquipmentTypeListRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.EquipmentTypeListResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.EquipmentTypeListRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = baseURL.replace(/\/$/, "") + "/api/v1/manage/equipment-types";

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...config?.headers };
        const queryParams: string = utils.serializeQueryParams(req);
        headers["Accept"] = "application/json";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url + queryParams,
            method: "get",
            headers: headers,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.EquipmentTypeListResponse = new operations.EquipmentTypeListResponse({
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.equipmentTypesList = utils.objectToClass(
                        httpRes?.data,
                        shared.EquipmentTypesList
                    );
                }
                break;
        }

        return res;
    }

    /**
     * Equipment type - Paged
     *
     * @remarks
     * Retrieve a list of equipment type entities by page number and page size.
     */
    async equipmentTypeListPaged(
        req: operations.EquipmentTypeListPagedRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.EquipmentTypeListPagedResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.EquipmentTypeListPagedRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = baseURL.replace(/\/$/, "") + "/api/v1/manage/equipment-types/paged";

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...config?.headers };
        const queryParams: string = utils.serializeQueryParams(req);
        headers["Accept"] = "application/json";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url + queryParams,
            method: "get",
            headers: headers,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.EquipmentTypeListPagedResponse =
            new operations.EquipmentTypeListPagedResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.equipmentTypesPaged = utils.objectToClass(
                        httpRes?.data,
                        shared.EquipmentTypesPaged
                    );
                }
                break;
        }

        return res;
    }

    /**
     * Equipment type - Update
     *
     * @remarks
     * Update a single equipment type entity.
     * PUT and PATCH update semantics as defined by REST.
     *  - **PUT**: Update properties and assign null where not defined in the request body.
     *  - **PATCH**: Update non-null properties from the request body and leave the remaining intact.
     *
     * See also: [Equipment type - JSON Patch](#operation/equipment_type-json-patch)
     */
    async equipmentTypeUpdatePatch(
        req: operations.EquipmentTypeUpdatePatchRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.EquipmentTypeUpdatePatchResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.EquipmentTypeUpdatePatchRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = utils.generateURL(baseURL, "/api/v1/manage/equipment-types/{id}", req);

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
                req,
                "equipmentTypeUpdateBody",
                "json"
            );
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...reqBodyHeaders, ...config?.headers };
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        headers["Accept"] = "application/json;q=1, application/json;q=0";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url,
            method: "patch",
            headers: headers,
            data: reqBody,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.EquipmentTypeUpdatePatchResponse =
            new operations.EquipmentTypeUpdatePatchResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.equipmentTypeResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.EquipmentTypeResponse
                    );
                }
                break;
            case httpRes?.status == 400:
                break;
            case httpRes?.status == 422:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.errorDetailResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.ErrorDetailResponse
                    );
                }
                break;
        }

        return res;
    }

    /**
     * Equipment type - Update
     *
     * @remarks
     * Update a single equipment type entity.
     * PUT and PATCH update semantics as defined by REST.
     *  - **PUT**: Update properties and assign null where not defined in the request body.
     *  - **PATCH**: Update non-null properties from the request body and leave the remaining intact.
     *
     * See also: [Equipment type - JSON Patch](#operation/equipment_type-json-patch)
     */
    async equipmentTypeUpdatePut(
        req: operations.EquipmentTypeUpdatePutRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.EquipmentTypeUpdatePutResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.EquipmentTypeUpdatePutRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = utils.generateURL(baseURL, "/api/v1/manage/equipment-types/{id}", req);

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
                req,
                "equipmentTypeUpdateBody",
                "json"
            );
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...reqBodyHeaders, ...config?.headers };
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        headers["Accept"] = "application/json;q=1, application/json;q=0";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url,
            method: "put",
            headers: headers,
            data: reqBody,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.EquipmentTypeUpdatePutResponse =
            new operations.EquipmentTypeUpdatePutResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.equipmentTypeResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.EquipmentTypeResponse
                    );
                }
                break;
            case httpRes?.status == 400:
                break;
            case httpRes?.status == 422:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.errorDetailResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.ErrorDetailResponse
                    );
                }
                break;
        }

        return res;
    }

    /**
     * Equipment - Update
     *
     * @remarks
     * Update a single equipment entity.
     * PUT and PATCH update semantics as defined by REST.
     *  - **PUT**: Update properties and assign null where not defined in the request body.
     *  - **PATCH**: Update non-null properties from the request body and leave the remaining intact.
     *
     * See also: [Equipment - JSON Patch](#operation/equipment-json-patch)
     */
    async equipmentUpdatePatch(
        req: operations.EquipmentUpdatePatchRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.EquipmentUpdatePatchResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.EquipmentUpdatePatchRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = utils.generateURL(baseURL, "/api/v1/manage/equipment/{id}", req);

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
                req,
                "equipmentUpdateBody",
                "json"
            );
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...reqBodyHeaders, ...config?.headers };
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        headers["Accept"] = "application/json;q=1, application/json;q=0";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url,
            method: "patch",
            headers: headers,
            data: reqBody,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.EquipmentUpdatePatchResponse =
            new operations.EquipmentUpdatePatchResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.equipmentResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.EquipmentResponse
                    );
                }
                break;
            case httpRes?.status == 400:
                break;
            case httpRes?.status == 422:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.errorDetailResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.ErrorDetailResponse
                    );
                }
                break;
        }

        return res;
    }

    /**
     * Equipment - Update
     *
     * @remarks
     * Update a single equipment entity.
     * PUT and PATCH update semantics as defined by REST.
     *  - **PUT**: Update properties and assign null where not defined in the request body.
     *  - **PATCH**: Update non-null properties from the request body and leave the remaining intact.
     *
     * See also: [Equipment - JSON Patch](#operation/equipment-json-patch)
     */
    async equipmentUpdatePut(
        req: operations.EquipmentUpdatePutRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.EquipmentUpdatePutResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.EquipmentUpdatePutRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = utils.generateURL(baseURL, "/api/v1/manage/equipment/{id}", req);

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
                req,
                "equipmentUpdateBody",
                "json"
            );
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...reqBodyHeaders, ...config?.headers };
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        headers["Accept"] = "application/json;q=1, application/json;q=0";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url,
            method: "put",
            headers: headers,
            data: reqBody,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.EquipmentUpdatePutResponse =
            new operations.EquipmentUpdatePutResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.equipmentResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.EquipmentResponse
                    );
                }
                break;
            case httpRes?.status == 400:
                break;
            case httpRes?.status == 422:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.errorDetailResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.ErrorDetailResponse
                    );
                }
                break;
        }

        return res;
    }

    /**
     * Tenant - Fetch
     *
     * @remarks
     * Retrieve a single tenant entity by ID.
     */
    async tenantFetch(
        req: operations.TenantFetchRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.TenantFetchResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.TenantFetchRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = utils.generateURL(baseURL, "/api/v1/manage/tenants/{id}", req);

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...config?.headers };
        headers["Accept"] = "application/json";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url,
            method: "get",
            headers: headers,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.TenantFetchResponse = new operations.TenantFetchResponse({
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.tenantResponse = utils.objectToClass(httpRes?.data, shared.TenantResponse);
                }
                break;
        }

        return res;
    }

    /**
     * Tenant - JSON Patch
     *
     * @remarks
     * Update a single tenant entity.
     * PATCH with `Content-Type: application/json-patch+json` supports a JSON Patch ([jsonpatch.com](http://jsonpatch.com)) document in `tenant` that has paths relative to schema `Tenant`.
     */
    async tenantJsonPatch(
        req: operations.TenantJsonPatchRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.TenantJsonPatchResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.TenantJsonPatchRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = utils.generateURL(
            baseURL,
            "/api/v1/manage/tenants/{id}/jsonpatch",
            req
        );

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
                req,
                "tenantJsonPatchBody",
                "json"
            );
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...reqBodyHeaders, ...config?.headers };
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        headers["Accept"] = "application/json;q=1, application/json;q=0";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url,
            method: "patch",
            headers: headers,
            data: reqBody,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.TenantJsonPatchResponse = new operations.TenantJsonPatchResponse({
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.tenantResponse = utils.objectToClass(httpRes?.data, shared.TenantResponse);
                }
                break;
            case httpRes?.status == 400:
                break;
            case httpRes?.status == 422:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.errorDetailResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.ErrorDetailResponse
                    );
                }
                break;
        }

        return res;
    }

    /**
     * Tenant - List
     *
     * @remarks
     * Retrieve a list of tenant entities by continuation token and page size.
     */
    async tenantList(
        req: operations.TenantListRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.TenantListResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.TenantListRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = baseURL.replace(/\/$/, "") + "/api/v1/manage/tenants";

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...config?.headers };
        const queryParams: string = utils.serializeQueryParams(req);
        headers["Accept"] = "application/json";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url + queryParams,
            method: "get",
            headers: headers,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.TenantListResponse = new operations.TenantListResponse({
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.tenantsList = utils.objectToClass(httpRes?.data, shared.TenantsList);
                }
                break;
        }

        return res;
    }

    /**
     * Tenant - Paged
     *
     * @remarks
     * Retrieve a list of tenant entities by page number and page size.
     */
    async tenantListPaged(
        req: operations.TenantListPagedRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.TenantListPagedResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.TenantListPagedRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = baseURL.replace(/\/$/, "") + "/api/v1/manage/tenants/paged";

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...config?.headers };
        const queryParams: string = utils.serializeQueryParams(req);
        headers["Accept"] = "application/json";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url + queryParams,
            method: "get",
            headers: headers,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.TenantListPagedResponse = new operations.TenantListPagedResponse({
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.tenantsPaged = utils.objectToClass(httpRes?.data, shared.TenantsPaged);
                }
                break;
        }

        return res;
    }

    /**
     * Tenant - Update
     *
     * @remarks
     * Update a single tenant entity.
     * PUT and PATCH update semantics as defined by REST.
     *  - **PUT**: Update properties and assign null where not defined in the request body.
     *  - **PATCH**: Update non-null properties from the request body and leave the remaining intact.
     *
     * See also: [Tenant - JSON Patch](#operation/tenant-json-patch)
     */
    async tenantUpdatePatch(
        req: operations.TenantUpdatePatchRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.TenantUpdatePatchResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.TenantUpdatePatchRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = utils.generateURL(baseURL, "/api/v1/manage/tenants/{id}", req);

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(req, "tenantUpdateBody", "json");
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...reqBodyHeaders, ...config?.headers };
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        headers["Accept"] = "application/json;q=1, application/json;q=0";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url,
            method: "patch",
            headers: headers,
            data: reqBody,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.TenantUpdatePatchResponse = new operations.TenantUpdatePatchResponse({
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.tenantResponse = utils.objectToClass(httpRes?.data, shared.TenantResponse);
                }
                break;
            case httpRes?.status == 400:
                break;
            case httpRes?.status == 422:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.errorDetailResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.ErrorDetailResponse
                    );
                }
                break;
        }

        return res;
    }

    /**
     * Tenant - Update
     *
     * @remarks
     * Update a single tenant entity.
     * PUT and PATCH update semantics as defined by REST.
     *  - **PUT**: Update properties and assign null where not defined in the request body.
     *  - **PATCH**: Update non-null properties from the request body and leave the remaining intact.
     *
     * See also: [Tenant - JSON Patch](#operation/tenant-json-patch)
     */
    async tenantUpdatePut(
        req: operations.TenantUpdatePutRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.TenantUpdatePutResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.TenantUpdatePutRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const url: string = utils.generateURL(baseURL, "/api/v1/manage/tenants/{id}", req);

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(req, "tenantUpdateBody", "json");
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }

        const client: AxiosInstance =
            this.sdkConfiguration.securityClient || this.sdkConfiguration.defaultClient;

        const headers = { ...reqBodyHeaders, ...config?.headers };
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        headers["Accept"] = "application/json;q=1, application/json;q=0";
        headers[
            "user-agent"
        ] = `speakeasy-sdk/${this.sdkConfiguration.language} ${this.sdkConfiguration.sdkVersion} ${this.sdkConfiguration.genVersion} ${this.sdkConfiguration.openapiDocVersion}`;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: url,
            method: "put",
            headers: headers,
            data: reqBody,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.TenantUpdatePutResponse = new operations.TenantUpdatePutResponse({
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.tenantResponse = utils.objectToClass(httpRes?.data, shared.TenantResponse);
                }
                break;
            case httpRes?.status == 400:
                break;
            case httpRes?.status == 422:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.errorDetailResponse = utils.objectToClass(
                        httpRes?.data,
                        shared.ErrorDetailResponse
                    );
                }
                break;
        }

        return res;
    }
}
